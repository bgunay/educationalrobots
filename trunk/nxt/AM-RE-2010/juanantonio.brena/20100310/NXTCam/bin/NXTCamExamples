
public Blob findObjectColor(int color) {

      // obtenemos el numero de objetos detectados
      int numObjs = camara.getNumberOfObjects();

      if (numObjs > 0) {
         // recorremos la relacion de objetos detectados
         for (int j = 0; j < numObjs; j++) {
            int clr = camara.getObjectColor(j);
            // si el blob es del color buscado
            if (clr == color) {
               Rectangle rect = camara.getRectangle(j);
               return new Blob(rect.x, rect.y, rect.width, rect.height,
                     clr);
            }
         }

      }
      return null;
   } 





import lejos.nxt.*;
import lejos.nxt.addon.*;

public class MyCam extends NXTCam{
   
   public MyCam(I2CPort port)
   {
      super(port);

   }
   
   
   public int[] getCoordinates(int id){
      byte[] buf = new byte[4];
      int[] coordBuf = new int[4];
      
      for(int i=0;i<4;i++) buf[i] = 0;
      getData(0x44 + (id * 5), buf, 4);
      
      for(int i=0;i<4;i++){
         coordBuf[i] = buf[i] & 0xFF;
      }
      
      return coordBuf;
   }
   
   
   
   public int getUnifiedWidth(int numObjects){
      int width = 0;
      int max = 0,min =0;
      int[] xVecLeft,xVecRight;
      
      xVecLeft = getXVecLeft(numObjects);
      xVecRight = getXVecRight(numObjects);
      
      max = maxVec(xVecRight);
      min = minVec(xVecLeft);
      
      width = max - min;
      return width;
   }

   public int[] getXVecLeft(int numObjects){
      
      int[] coordBuf = new int[4];
      for(int i=0;i<4;i++) coordBuf[i] = 0;
      int[] xVecLeft = new int[numObjects];
      
      for(int j = 0;j<numObjects;j++){
         xVecLeft[j]=0;
      }
      
      for(int i = 0;i<numObjects;i++){
         coordBuf = getCoordinates(i);
            
         xVecLeft[i] = coordBuf[0];
      }      
      
      return xVecLeft;
   }
   
   
   public int[] getXVecRight(int numObjects){
      
      int[] coordBuf = new int[4];
      for(int i=0;i<4;i++) coordBuf[i] = 0;
      
      int[] xVecRight = new int[numObjects];
      for(int j = 0;j<numObjects;j++){
         xVecRight[j]=0;
      }
      
      for(int i = 0;i<numObjects;i++){
         coordBuf = getCoordinates(i);
            
         xVecRight[i] = coordBuf[3];
      }      
      
      return xVecRight;
   }
   
   public int minVec(int[] vec){
      int min = vec[0];
      for(int i = 1;i<vec.length;i++){
         if(min>vec[i]){
            min = vec[i];
         }
      }
      
      return min;
   }
   public int maxVec(int[] vec){
      int max = vec[0];
      for(int i = 1;i<vec.length;i++){
         if(max<vec[i]){
            max = vec[i];
         }
      }
      return max;
   }


} 

import lejos.nxt.*;
import lejos.nxt.addon.*;

public class MyCam2 extends NXTCam{


   
      public MyCam2(I2CPort port)
      {
         super(port);
      }
      
      
      public int[] getAllCoordinates( int numObjects )
      {
         byte[] buf = new byte[4];
         int[] coordBuf = new int[4*numObjects];
         for( int id = 0; id < numObjects; id++ )
         {
            for(int i=0;i<4;i++) buf[i] = 0;
            getData(0x44 + (id * 5), buf, 4);
         
            for(int i=0;i<4;i++){
               coordBuf[4 * id + i] = buf[i] & 0xFF;
            }
         }
         
         return coordBuf;
      }

      public int[] getCoordinates(int id, int[]allBuf){

         int[] coordBuf = new int[4];
         
         for(int i=0;i<4;i++){
            coordBuf[i] = allBuf[4*id + i];
         }
         
         return coordBuf;
      }
      
      
      
      public int getUnifiedWidth(int[] allBuf){
         int width = 0;
         int max = 0,min =0;
         int[] xVecLeft,xVecRight;
         
         xVecLeft = getXVecLeft(allBuf);
         xVecRight = getXVecRight(allBuf);
         
         max = maxVec(xVecRight);
         min = minVec(xVecLeft);
         
         width = max - min;
         return width;
      }

      
      public int[] getXVecLeft(int[] allBuf){
                  
         int[] coordBuf = new int[4];
         for(int i=0;i<4;i++) coordBuf[i] = 0;
         int[] xVecLeft = new int[allBuf.length/4];
         
         for(int j = 0;j<allBuf.length/4;j++){
            xVecLeft[j]=0;
         }
         
         for(int i = 0;i<allBuf.length/4;i++){
            coordBuf = getCoordinates(i, allBuf);
            xVecLeft[i] = coordBuf[0];
         }      
         
         return xVecLeft;
                                       
      }
      
      public int[] getXVecRight( int[] allBuf){
         
         int[] coordBuf = new int[4];
         for(int i=0;i<4;i++) coordBuf[i] = 0;
         
         int[] xVecRight = new int[allBuf.length/4];
         for(int j = 0;j<allBuf.length/4;j++){
            xVecRight[j]=0;
         }
         
         for(int i = 0;i<allBuf.length/4;i++){
            coordBuf = getCoordinates(i,allBuf);
            xVecRight[i] = coordBuf[2];
         }
         return xVecRight;
      }
      
      

      
      public int minVec(int[] vec){
         int min = vec[0];
         for(int i = 1;i<vec.length;i++){
            if(min>vec[i]){
               min = vec[i];
            }
         }
         
         return min;
      }
      
      
      
      
      public int maxVec(int[] vec){
         int max = vec[0];
         for(int i = 1;i<vec.length;i++){
            if(max<vec[i]){
               max = vec[i];
            }
         }
         return max;
      }


} 

import java.awt.Rectangle;

import lejos.nxt.I2CPort;
import lejos.nxt.I2CSensor;

public class NXTCamCustom extends I2CSensor {
   byte[] buf = new byte[4];
   
   int areaFilterLow = 0;
   int areaFilterHigh = 0;
   int dimFilterLow = 0;
   int dimFilterHigh = 0;

   static final int TOPLEFT = 0;
   static final int TOPCENTER = 1;
   static final int TOPRIGHT = 2;
   static final int MIDDLELEFT = 3;
   static final int MIDDLECENTER = 4;
   static final int MIDDLERIGHT = 5;
   static final int BOTTOMLEFT = 6;
   static final int BOTTOMCENTER = 7;
   static final int BOTTOMRIGHT = 8;

   boolean useMerging = false;
   boolean useFiltering = false;
   
   public NXTCamCustom(I2CPort port)
   {
      super(port);
      port.setType(TYPE_LOWSPEED_9V);
   }
   
   public int getNumberOfObjects() {
      int ret = getData(0x42, buf, 1);
      if(ret != 0) return -1;
      return (0xFF & buf[0]);
   }
   
   private int getObjectColor(int id) {
      int ret = getData(0x43 + (id * 5), buf, 1);
      if(ret != 0) return -1;
      return (0xFF & buf[0]);
   }
   
   private TrackedObject getObject(int id) {
      for (int i = 0; i < 4; i++)
         buf[i] = 0;
      getData(0x44 + (id * 5), buf, 4);
      return new TrackedObject(buf[0] & 0xFF, buf[1] & 0xFF, (buf[2] & 0xFF) - (buf[0] & 0xFF), (buf[3] & 0xFF) - (buf[1] & 0xFF), getObjectColor(id));
   }
   
   public TrackedObject[] getObjects() {

      TrackedObject[] newObjs = new TrackedObject[8];

      for (int id = 0; id < 8; id++) {
         newObjs[id] = getObject(id);
      }
      if (useMerging) {
         newObjs = mergeObjects(newObjs);
      }
      if (useFiltering) {
         newObjs = filterObjects(newObjs);
      }
      return newObjs;
   }
   
   TrackedObject[] mergeObjects(TrackedObject[] objects) {
      
      TrackedObject[] mergedObjs = objects;

      boolean merged = true;
      while (merged == true) {
         merged = false;
         for (int i = 0; i < mergedObjs.length; i++) {
            for (int j = 0; j < mergedObjs.length; j++) {
               if (i != j && mergeObejcts(mergedObjs[i], mergedObjs[j]) != null) {
                  mergedObjs[i] = mergeObejcts(mergedObjs[i], mergedObjs[j]);
                  mergedObjs[j] = null;
                  merged = true;
               }
            }
         }
      }
      return mergedObjs;

   }

   TrackedObject mergeObejcts(TrackedObject obj1, TrackedObject obj2) {

      if (obj1 == null || obj2 == null)
         return null;
      if (obj1.isNull() || obj2.isNull())
         return null;
      if (obj1.color != obj2.color)
         return null;

      if (obj1.intersects(obj2))
         return new TrackedObject(Math.min(obj1.x, obj2.x), Math.min(obj1.y, obj2.y), Math.max(obj1.width + obj1.x, obj2.width + obj2.x) - Math.min(obj1.x, obj2.x), Math.max(obj1.height + obj1.y, obj2.height + obj2.y) - Math.min(obj1.y, obj2.y), obj1.color);

      return null;
   }

   TrackedObject[] filterObjects(TrackedObject[] objects) {
      TrackedObject[] filteredObjs = objects;
      
      for (int c=0; c<filteredObjs.length; c++) {
         if (areaFilterLow != 0) {
            if (filteredObjs[c].getArea() < areaFilterLow)
               filteredObjs[c] = null;
         }
         
         if (areaFilterHigh != 0) {
            if (filteredObjs[c].getArea() > areaFilterHigh) {
               filteredObjs[c] = null;
            }
         }
         if (dimFilterLow != 0) {
            if (filteredObjs[c].width < dimFilterLow || filteredObjs[c].height < dimFilterLow) {
               filteredObjs[c] = null;
            }
         }
         if (dimFilterHigh != 0) {
            if (filteredObjs[c].width > dimFilterHigh || filteredObjs[c].height > dimFilterHigh) {
               filteredObjs[c] = null;
            }
         }
      }
      return filteredObjs;
   }

   TrackedObject filterObject(TrackedObject object) {
      
         if (areaFilterLow != 0) {
            if (object.getArea() < areaFilterLow)
               return null;
         }
         
         if (areaFilterHigh != 0) {
            if (object.getArea() > areaFilterHigh) {
               return null;
            }
         }
         if (dimFilterLow != 0) {
            if (object.width < dimFilterLow || object.height < dimFilterLow) {
               return null;
            }
         }
         if (dimFilterHigh != 0) {
            if (object.width > dimFilterHigh || object.height > dimFilterHigh) {
               return null;
            }
         }
      
      return object;
   }
   
   Rectangle getPoint(TrackedObject obj, int point) {

      switch (point) {
         case 0:
            return new Rectangle(obj.x, obj.y, 0, 0);
         case 1:
            return new Rectangle(obj.x + (obj.width / 2), obj.y, 0, 0);
         case 2:
            return new Rectangle(obj.x + obj.width, obj.y, 0, 0);
         case 3:
            return new Rectangle(obj.x, obj.y + (obj.height / 2), 0, 0);
         case 4:
            return new Rectangle(obj.x + (obj.width / 2), obj.y + (obj.height / 2), 0, 0);
         case 5:
            return new Rectangle(obj.x + obj.width, obj.y + (obj.height / 2), 0, 0);
         case 6:
            return new Rectangle(obj.x, obj.y + obj.height, 0, 0);
         case 7:
            return new Rectangle(obj.x + (obj.width / 2), obj.y + obj.height, 0, 0);
         case 8:
            return new Rectangle(obj.x + obj.width, obj.y + obj.height, 0, 0);
      }
      return new Rectangle(0, 0, 0, 0);
   }

   TrackedObject getTopObj(TrackedObject[] objs, int point) {

      TrackedObject obj = null;
      for (int c = 0; c < objs.length; c++) {
         if (!objs[c].isNull()) {
            if (obj == null) {
               obj = objs[c];
            } else {
               if (getPoint(obj, point).y < getPoint(objs[c], point).y) {
                  obj = objs[c];
               }
            }
         }
      }
      return obj;
   }

   TrackedObject getBottomObj(TrackedObject[] objs, int point) {

      TrackedObject obj = null;
      for (int c = 0; c < objs.length; c++) {
         if (!objs[c].isNull()) {
            if (obj == null) {
               obj = objs[c];
            } else {
               if (getPoint(obj, point).y > getPoint(objs[c], point).y) {
                  obj = objs[c];
               }
            }
         }
      }
      return obj;
   }

   TrackedObject getRightObj(TrackedObject[] objs, int point) {

      TrackedObject obj = null;
      for (int c = 0; c < objs.length; c++) {
         if (!objs[c].isNull()) {
            if (obj == null) {
               obj = objs[c];
            } else {
               if (getPoint(obj, point).x > getPoint(objs[c], point).x) {
                  obj = objs[c];
               }
            }
         }
      }
      return obj;
   }

   TrackedObject getLeftObj(TrackedObject[] objs, int point) {

      TrackedObject obj = null;
      for (int c = 0; c < objs.length; c++) {
         if (!objs[c].isNull()) {
            if (obj == null) {
               obj = objs[c];
            } else {
               if (getPoint(obj, point).x < getPoint(objs[c], point).x) {
                  obj = objs[c];
               }
            }
         }
      }
      return obj;
   }
   
   public void sendCommand(char cmd) {
      sendData(0x41, (byte) cmd);
   }
   
}




import lejos.nxt.*;

public class CamTrackTest {

   static NXTCamCustom nxtCamLine = new NXTCamCustom(SensorPort.S3);
   
   public static void main(String[] args) {
      
      nxtCamLine.enableTracking();
      
      Sound.beep();
      sleep(500);
      
      nxtCamLine.selectLineTrackingMode();
      
      Sound.beep();
      sleep(500);

      while (!Button.ESCAPE.isPressed()) {
         LCD.clear();
         
         LCD.drawString(nxtCamLine.getProductID(),1,0);
         LCD.drawInt(nxtCamLine.getCameraEngineFirmwareVersion(), 1, 1);
         LCD.drawInt(nxtCamLine.getNumberOfObjectDetected(), 1, 2);
         LCD.drawInt(nxtCamLine.pingCameraEngine(), 1, 3);
         
         LCD.drawInt(nxtCamLine.getXUpperLeft(), 1, 4);
         LCD.drawInt(nxtCamLine.getYLowerRight(), 1, 5);
         
         LCD.refresh();
         
         sleep(500);
      }

   }
   
   static void sleep(int mills) {
      try {
         Thread.sleep(mills);
      } catch (InterruptedException e) {

      }
   }

}



